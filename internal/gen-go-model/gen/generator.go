package gen

import (
	"fmt"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"dbml-go/core"
	"dbml-go/internal/gen-go-model/genutil"

	"github.com/dave/jennifer/jen"
)

const (
	version = "v1.0.0"
)

type generator struct {
	dbml             *core.DBML
	out              string
	gopackage        string
	fieldtags        []string
	types            map[string]jen.Code
	shouldGenTblName bool
	isPostgres       bool
}

func newgen() *generator {
	return &generator{
		types: make(map[string]jen.Code),
	}
}

func (g *generator) reset(rememberAlias bool) {
	g.dbml = nil
	if !rememberAlias {
		g.types = make(map[string]jen.Code)
	}
}

func (g *generator) file() *jen.File {
	return jen.NewFilePathName(g.out, g.gopackage)
}

func (g *generator) generate() (err error) {
	err = g.genDoc()
	if err != nil {
		return
	}

	for _, enum := range g.dbml.Enums {
		if err = g.genEnum(enum); err != nil {
			return
		}
	}
	for _, table := range g.dbml.Tables {
		if err = g.genTable(table); err != nil {
			return err
		}
	}

	return nil
}

func (g *generator) headerComments() string {
	return fmt.Sprintf(`Generated by dbml-go
    version: %s
    timestamp: %s
`, version, time.Now().String())
}

func (g *generator) genDoc() error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	f.PackageComment(fmt.Sprintf("package %s is autogenerated from a database markup language document.", g.gopackage))
	f.PackageComment("It provides handy wrappers and such to database operations")
	f.PackageComment(g.headerComments())

	return f.Save(filepath.Join(g.out, "doc.go"))
}

func (g *generator) genEnum(enum core.Enum) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	enumOriginName := genutil.NormalizeTypeName(enum.Name)
	enumGoTypeName := genutil.NormalizeGoTypeName(enum.Name)

	f.Commentf("%s is generated type for enum '%s'", enumGoTypeName, enumOriginName)

	f.Type().Id(enumGoTypeName).Int64()

	f.Const().DefsFunc(func(group *jen.Group) {
		group.Id("_").Id(enumGoTypeName).Op("=").Iota()

		for _, value := range enum.Values {
			v := group.Id(genutil.NormalLizeGoName(value.Name))
			if value.Note != "" {
				v.Comment(value.Note)
			}
		}
	})

	f.Commentf("Scan implements Scan() from the sql.Scanner interface for %q", enumOriginName)
	f.Commentf("See: https://pkg.go.dev/database/sql#Scanner")

	f.Func().Params(
		jen.Id("v").Op("*").Id(enumGoTypeName),
	).Id("Scan").Params(
		jen.Id("i").Interface(),
	).Params(jen.Err().Error()).Block(
		jen.List(jen.Id("s"), jen.Id("ok")).Op(":=").Id("i").Assert(jen.Index().Uint8()),
		jen.If(jen.Op("!").Id("ok").Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.List(jen.Lit("value (%#v) is not of the expected type []uint8"), jen.Id("i")))),
		)),
		jen.Switch().BlockFunc(func(group *jen.Group) {
			for _, value := range enum.Values {
				v := genutil.NormalLizeGoName(value.Name)

				group.Case(jen.Qual("reflect", "DeepEqual").Call(jen.List(jen.Id("s"), jen.Index().Uint8().Params(jen.Lit(value.Name))))).Block(
					jen.Op("*").Id("v").Op("=").Id(v),
				)
			}

			group.Default().Block(
				jen.Err().Op("=").Qual("fmt", "Errorf").Call(jen.List(jen.Lit(fmt.Sprintf("unable to parse %%#v into a known %s type", enumGoTypeName)), jen.Id("i"))),
			)
		}),
		jen.Return(),
	)

	f.Commentf("Value implements Value() from the driver.Valuer interface for %q", enumOriginName)
	f.Commentf("See: https://pkg.go.dev/database/sql/driver#Valuer")

	if g.isPostgres {
		f.Func().Params(
			jen.Id("v").Id(enumGoTypeName),
		).Id("Value").Params().Params(jen.Id("out").Qual("database/sql/driver", "Value"), jen.Id("err").Error()).Block(
			jen.Switch(jen.Id("v")).BlockFunc(func(group *jen.Group) {
				for idx, value := range enum.Values {
					group.Case(jen.Lit(idx + 1)).Block(
						jen.Id("out").Op("=").Lit(value.Name),
					)
				}

				group.Default().Block(
					jen.Err().Op("=").Qual("fmt", "Errorf").Call(jen.List(jen.Lit(fmt.Sprintf("unable to parse %%#v into a known %s string", enumGoTypeName)), jen.Id("v"))),
				)
			}),
			jen.Return(),
		)
	} else {
		f.Func().Params(
			jen.Id("v").Id(enumGoTypeName),
		).Id("Value").Params().Params(jen.Qual("database/sql/driver", "Value"), jen.Error()).Block(
			jen.Return(jen.List(jen.Int64().Params(jen.Id("v")), jen.Nil())),
		)
	}

	f.Comment(g.headerComments())

	g.types[enum.Name] = jen.Id(enumGoTypeName)

	return f.Save(filepath.Join(g.out, fmt.Sprintf("%s.go", genutil.Normalize(enum.Name))))
}

func (g *generator) genTable(table core.Table) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	tableOriginName := genutil.Normalize(table.Name)
	tableGoTypeName := genutil.NormalizeGoTypeName(table.Name)

	f.Commentf("%s is generated type for table '%s'", tableGoTypeName, tableOriginName)

	var genColumnErr error

	tableMetadataType := "__tbl_" + tableOriginName
	tableMetadataColumnsType := tableMetadataType + "_columns"

	f.Commentf("// table '%s' columns list struct", tableOriginName)
	f.Type().Id(tableMetadataColumnsType).StructFunc(func(group *jen.Group) {
		for _, column := range table.Columns {
			group.Id(genutil.NormalLizeGoName(column.Name)).String()
		}
	})

	f.Commentf("// table '%s' metadata struct", tableOriginName)
	f.Type().Id("__tbl_"+tableOriginName).Struct(
		jen.Id("Name").String(),
		jen.Id("Columns").Id(tableMetadataColumnsType),
	)

	tableMetadataVar := "_tbl_" + tableOriginName

	f.Commentf("// table '%s' metadata info", tableOriginName)
	f.Var().Id(tableMetadataVar).Op("=").Id(tableMetadataType).Values(jen.DictFunc(func(d jen.Dict) {
		d[jen.Id("Name")] = jen.Lit(tableOriginName)
		d[jen.Id("Columns")] = jen.Id(tableMetadataColumnsType).Values(jen.DictFunc(func(d jen.Dict) {
			for _, column := range table.Columns {
				columnName := genutil.NormalLizeGoName(column.Name)
				columnOriginName := genutil.Normalize(column.Name)
				d[jen.Id(columnName)] = jen.Lit(columnOriginName)
			}
		}))
	}))

	f.Commentf("GetColumns return list columns name for table '%s'", tableOriginName)
	f.Func().Params(
		jen.Op("*").Id(tableMetadataType),
	).Id("GetColumns").Params().Index().String().Block(
		jen.Return(jen.Index().String().ValuesFunc(func(g *jen.Group) {
			for _, col := range table.Columns {
				g.Lit(col)
			}
		})),
	)

	f.Commentf("T return metadata info for table '%s'", tableOriginName)
	f.Func().Params(
		jen.Op("*").Id(tableGoTypeName),
	).Id("T").Params().Op("*").Id(tableMetadataType).Block(
		jen.Return().Op("&").Id(tableMetadataVar),
	)

	if g.shouldGenTblName {
		f.Commentf("TableName return table name")
		f.Func().Params(
			jen.Id(tableGoTypeName),
		).Id("TableName").Params().Id("string").Block(
			jen.Return(jen.Lit(tableOriginName)),
		)
	}

	cols := make([]string, 0)

	f.Type().Id(tableGoTypeName).StructFunc(func(group *jen.Group) {
		for _, column := range table.Columns {
			columnName := genutil.NormalLizeGoName(column.Name)
			columnOriginName := genutil.Normalize(column.Name)
			t, ok := g.getJenType(column.Type)
			if !ok {
				genColumnErr = fmt.Errorf("type '%s' is not support", column.Type)
			}
			if column.Settings.Note != "" {
				group.Comment(column.Settings.Note)
			}

			gotags := make(map[string]string)
			for _, t := range g.fieldtags {
				gotags[strings.TrimSpace(t)] = columnOriginName
			}
			group.Id(columnName).Add(t).Tag(gotags)
			cols = append(cols, columnOriginName)
		}
	})

	f.Comment(g.headerComments())

	if genColumnErr != nil {
		return genColumnErr
	}

	return f.Save(filepath.Join(g.out, fmt.Sprintf("%s.go", genutil.Normalize(table.Name))))
}

const primeTypePattern = `^(\w+)(\(d+\))?`

var (
	regexType    = regexp.MustCompile(primeTypePattern)
	builtinTypes = map[string]jen.Code{
		"int":       jen.Int(),
		"integer":   jen.Int(),
		"int8":      jen.Int8(),
		"int16":     jen.Int16(),
		"int32":     jen.Int32(),
		"int64":     jen.Int64(),
		"bigint":    jen.Int64(),
		"uint":      jen.Uint(),
		"uint8":     jen.Uint8(),
		"uint16":    jen.Uint16(),
		"uint32":    jen.Uint32(),
		"uint64":    jen.Uint64(),
		"float":     jen.Float64(),
		"float32":   jen.Float32(),
		"float64":   jen.Float64(),
		"bool":      jen.Bool(),
		"boolean":   jen.Bool(),
		"text":      jen.String(),
		"varchar":   jen.String(),
		"char":      jen.String(),
		"byte":      jen.Byte(),
		"rune":      jen.Rune(),
		"timestamp": jen.Qual("time", "Time"),
		"datetime":  jen.Qual("time", "Time"),
	}
)

func (g *generator) getJenType(s string) (jen.Code, bool) {
	m := regexType.FindStringSubmatch(s)
	if len(m) >= 2 {
		// lookup for builtin type
		if t, ok := builtinTypes[m[1]]; ok {
			return t, ok
		}
	}
	t, ok := g.types[s]
	return t, ok
}
